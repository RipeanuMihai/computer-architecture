"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[8959],{5680:(e,a,r)=>{r.d(a,{xA:()=>u,yg:()=>s});var i=r(6540);function t(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,i)}return r}function l(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach((function(a){t(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function o(e,a){if(null==e)return{};var r,i,t=function(e,a){if(null==e)return{};var r,i,t={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||(t[r]=e[r]);return t}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var p=i.createContext({}),c=function(e){var a=i.useContext(p),r=a;return e&&(r="function"==typeof e?e(a):l(l({},a),e)),r},u=function(e){var a=c(e.components);return i.createElement(p.Provider,{value:a},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},g=i.forwardRef((function(e,a){var r=e.components,t=e.mdxType,n=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(r),g=t,s=d["".concat(p,".").concat(g)]||d[g]||m[g]||n;return r?i.createElement(s,l(l({ref:a},u),{},{components:r})):i.createElement(s,l({ref:a},u))}));function s(e,a){var r=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var n=r.length,l=new Array(n);l[0]=g;var o={};for(var p in a)hasOwnProperty.call(a,p)&&(o[p]=a[p]);o.originalType=e,o[d]="string"==typeof e?e:t,l[1]=o;for(var c=2;c<n;c++)l[c]=r[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,r)}g.displayName="MDXCreateElement"},7048:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var i=r(8168),t=(r(6540),r(5680));const n={},l="Practic\u0103: Implementare modul UAL",o={unversionedId:"Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Practic\u0103/README",id:"Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Practic\u0103/README",title:"Practic\u0103: Implementare modul UAL",description:"Con\u021binutul laboratorului este prezent la urm\u0103torul link.",source:"@site/docs/Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Practic\u0103/README.md",sourceDirName:"Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Practic\u0103",slug:"/Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Practic\u0103/",permalink:"/computer-architecture/Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Practic\u0103/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Unitatea aritmetic\u0103-logic\u0103 (UAL)",permalink:"/computer-architecture/Laboratoare/6 Verilog Secven\u021bial/Unitate aritmetica logica/Teorie/"},next:{title:"7 Calculator Didactic",permalink:"/computer-architecture/Laboratoare/7 Calculator Didactic/"}},p={},c=[{value:"Opera\u021biile",id:"opera\u021biile",level:2},{value:"Adunarea cu carry (ADC)",id:"adunarea-cu-carry-adc",level:3},{value:"Sc\u0103derile (SBB1/SBB2)",id:"sc\u0103derile-sbb1sbb2",level:3},{value:"Opera\u021biile logice (AND/OR/XOR/NOT) \u0219i de shift (SHL/SHR/SAR)",id:"opera\u021biile-logice-andorxornot-\u0219i-de-shift-shlshrsar",level:3},{value:"Zero (Z), Sign (S), Parity (P)",id:"zero-z-sign-s-parity-p",level:3},{value:"Extra operations",id:"extra-operations",level:2},{value:"XNOR",id:"xnor",level:3},{value:"MUL",id:"mul",level:3},{value:"DIV",id:"div",level:3},{value:"MOD",id:"mod",level:3}],u={toc:c},d="wrapper";function m(e){let{components:a,...r}=e;return(0,t.yg)(d,(0,i.A)({},u,r,{components:a,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"practic\u0103-implementare-modul-ual"},"Practic\u0103: Implementare modul UAL"),(0,t.yg)("p",null,"Con\u021binutul laboratorului este prezent la urm\u0103torul ",(0,t.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture/tree/main/chapters/microprogramable_cpu/arithmetic-logic-unit/drills/alu/support"},"link"),"."),(0,t.yg)("p",null,"Vom completa con\u021binutul ",(0,t.yg)("strong",{parentName:"p"},"modulului alu"),", folosind intr\u0103rile \u0219i ie\u0219irile prezentate mai jos."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"module alu #(\n    parameter p_data_width = 5, // 5 for FPGA testing, 16 for Simulation and inside the CPU\n    parameter p_flags_width = 5\n)(\n    output wire [(p_data_width-1):0] o_w_out,\n    output wire [(p_flags_width-1):0] o_w_flags,\n    input wire [(p_data_width-1):0] i_w_op1,\n    input wire [(p_data_width-1):0] i_w_op2,\n    input wire [3:0] i_w_opcode,\n    input wire i_w_carry,\n    input wire i_w_oe\n);\n")),(0,t.yg)("p",null,"Codurile de identificare ale opera\u021biilor (cei 4 bi\u021bi S) sunt definite \xeen modulul ",(0,t.yg)("inlineCode",{parentName:"p"},"alu.v")," din scheletul de laborator \u0219i \xeen codul de mai jos."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"localparam ADC  = 4'd0;\nlocalparam SBB1 = 4'd1;\nlocalparam SBB2 = 4'd2;\nlocalparam NOT  = 4'd3;\nlocalparam AND  = 4'd4;\nlocalparam OR   = 4'd5;\nlocalparam XOR  = 4'd6;\nlocalparam SHL  = 4'd7;\nlocalparam SHR  = 4'd8;\nlocalparam SAR  = 4'd9;\n")),(0,t.yg)("h2",{id:"opera\u021biile"},"Opera\u021biile"),(0,t.yg)("p",null,"Partea combina\u021bional\u0103 a modulului descrie comportamentul fiec\u0103rei opera\u021bii \xeen func\u021bie de codul opera\u021bional ",(0,t.yg)("inlineCode",{parentName:"p"},"i_w_opcode")," prin intermediul unei structuri ",(0,t.yg)("inlineCode",{parentName:"p"},"case"),"."),(0,t.yg)("h3",{id:"adunarea-cu-carry-adc"},"Adunarea cu carry (ADC)"),(0,t.yg)("p",null,"Se execut\u0103 adunarea celor 2 operanzi \u0219i carry, iar \xeen cazul \xeen care rezultatul dep\u0103\u0219e\u0219te ca m\u0103rime parametrul ",(0,t.yg)("inlineCode",{parentName:"p"},"p_data_width"),", bitul \xeen plus activeaz\u0103 flag-ul ",(0,t.yg)("em",{parentName:"p"},"carry"),"."),(0,t.yg)("p",null,"Flag-ul de ",(0,t.yg)("em",{parentName:"p"},"overflow")," este activat cu 2 condi\u021bii:"),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"MSB"),"-ul operanzilor este egal. Acest bit indic\u0103 dac\u0103 operandul este un num\u0103r pozitiv sau negativ, iar suma dintre dou\u0103 numere de semn opus nu poate dep\u0103\u0219i intervalul lor."),(0,t.yg)("li",{parentName:"ol"},(0,t.yg)("strong",{parentName:"li"},"MSB"),"-ul rezultatului difer\u0103 de cel al operanzilor, indic\xe2nd c\u0103 a avut loc overflow-ul")),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"ADC: begin\n    {l_r_carry, l_r_result} = i_w_op1 + i_w_op2 + i_w_carry;\n    l_r_overflow = (i_w_op1[p_data_width-1] == i_w_op2[p_data_width-1]) &&\n                    (i_w_op1[p_data_width-1] != l_r_result[p_data_width-1]);\nend\n")),(0,t.yg)("h3",{id:"sc\u0103derile-sbb1sbb2"},"Sc\u0103derile (SBB1/SBB2)"),(0,t.yg)("p",null,"Condi\u021biile pentru activarea semnalelor de ",(0,t.yg)("em",{parentName:"p"},"carry")," \u0219i ",(0,t.yg)("em",{parentName:"p"},"overflow")," sunt asem\u0103n\u0103toare cu cele din cazul adun\u0103rii, cu excep\u021bia primei condi\u021bii de ",(0,t.yg)("em",{parentName:"p"},"overflow"),", care e inversat\u0103."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"i_w_op2[p_data_width-1] != i_w_op1[p_data_width-1]\n")),(0,t.yg)("h3",{id:"opera\u021biile-logice-andorxornot-\u0219i-de-shift-shlshrsar"},"Opera\u021biile logice (AND/OR/XOR/NOT) \u0219i de shift (SHL/SHR/SAR)"),(0,t.yg)("p",null,"Se observ\u0103 c\u0103 opera\u021biile logice nu activeaz\u0103 semnalele ",(0,t.yg)("em",{parentName:"p"},"carry")," \u0219i ",(0,t.yg)("em",{parentName:"p"},"overflow"),", iar \xeen cazul opera\u021biilor cu un singur operand (NOT/SHL/SHR/SAR), datorit\u0103 operatorului ",(0,t.yg)("inlineCode",{parentName:"p"},"|"),", acesta se poate afla pe oricare din intr\u0103ri ",(0,t.yg)("inlineCode",{parentName:"p"},"i_w_op1")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"i_w_op2")," cu condi\u021bia ca cealalt\u0103 s\u0103 aib\u0103 valoarea ",(0,t.yg)("strong",{parentName:"p"},"0"),"."),(0,t.yg)("p",null,"De asemenea opera\u021bia ",(0,t.yg)("inlineCode",{parentName:"p"},"SAL")," lipse\u0219te \xeentruc\xe2t e identic\u0103 cu ",(0,t.yg)("inlineCode",{parentName:"p"},"SHL"),"."),(0,t.yg)("p",null,"Operatiile de shift la stanga verifica ",(0,t.yg)("strong",{parentName:"p"},"MSB"),"-ul operandului pentru activarea flag-ului ",(0,t.yg)("em",{parentName:"p"},"carry"),", iar operatiile de shift la dreapta verifica ",(0,t.yg)("strong",{parentName:"p"},"LSB"),"-ul."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"// SHL/SAL\nl_r_carry = i_w_op1[p_data_width-1] | i_w_op2[p_data_width - 1];\n\n// SHR/SAR\nl_r_carry = i_w_op1[0] | i_w_op2[0];\n")),(0,t.yg)("p",null,"Pentru activarea flagului ",(0,t.yg)("em",{parentName:"p"},"overflow")," operatiile de shift verifica schimbarea ",(0,t.yg)("strong",{parentName:"p"},"MSB"),"-ului deoarece acesta este ",(0,t.yg)("em",{parentName:"p"},"bitul de semn"),"."),(0,t.yg)("h3",{id:"zero-z-sign-s-parity-p"},"Zero (Z), Sign (S), Parity (P)"),(0,t.yg)("p",null,"Aceste semnale au acelea\u0219i condi\u021bii de activare indiferent de opera\u021bia efectuat\u0103. De asemenea paritatea este verificat\u0103 prin operatorul de reducere ",(0,t.yg)("em",{parentName:"p"},"XNOR"),"."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"l_r_zero = l_r_result == 0;\nl_r_sign = l_r_result[p_data_width-1];\nl_r_parity = ~^l_r_result;\n")),(0,t.yg)("h2",{id:"extra-operations"},"Extra operations"),(0,t.yg)("h3",{id:"xnor"},"XNOR"),(0,t.yg)("h3",{id:"mul"},"MUL"),(0,t.yg)("h3",{id:"div"},"DIV"),(0,t.yg)("h3",{id:"mod"},"MOD"))}m.isMDXComponent=!0}}]);