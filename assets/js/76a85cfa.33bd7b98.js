"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[7360],{5680:(e,r,a)=>{a.d(r,{xA:()=>s,yg:()=>f});var t=a(6540);function i(e,r,a){return r in e?Object.defineProperty(e,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[r]=a,e}function n(e,r){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var r=1;r<arguments.length;r++){var a=null!=arguments[r]?arguments[r]:{};r%2?n(Object(a),!0).forEach((function(r){i(e,r,a[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(a,r))}))}return e}function l(e,r){if(null==e)return{};var a,t,i=function(e,r){if(null==e)return{};var a,t,i={},n=Object.keys(e);for(t=0;t<n.length;t++)a=n[t],r.indexOf(a)>=0||(i[a]=e[a]);return i}(e,r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)a=n[t],r.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=t.createContext({}),u=function(e){var r=t.useContext(c),a=r;return e&&(a="function"==typeof e?e(r):o(o({},r),e)),a},s=function(e){var r=u(e.components);return t.createElement(c.Provider,{value:r},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},d=t.forwardRef((function(e,r){var a=e.components,i=e.mdxType,n=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=u(a),d=i,f=m["".concat(c,".").concat(d)]||m[d]||p[d]||n;return a?t.createElement(f,o(o({ref:r},s),{},{components:a})):t.createElement(f,o({ref:r},s))}));function f(e,r){var a=arguments,i=r&&r.mdxType;if("string"==typeof e||i){var n=a.length,o=new Array(n);o[0]=d;var l={};for(var c in r)hasOwnProperty.call(r,c)&&(l[c]=r[c]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<n;u++)o[u]=a[u];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5731:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>n,metadata:()=>l,toc:()=>u});var t=a(8168),i=(a(6540),a(5680));const n={},o="Practice: Memory",l={unversionedId:"Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/README",id:"Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/README",title:"Practice: Memory",description:"Solu\u021bia se afl\u0103 \xeen repo-ul materiei GitHub.",source:"@site/docs/Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/README.md",sourceDirName:"Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103",slug:"/Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/",permalink:"/computer-architecture/Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Memorie",permalink:"/computer-architecture/Laboratoare/5 Verilog Secven\u021bial/Memorie/Teorie/"},next:{title:"6 Verilog Secven\u021bial",permalink:"/computer-architecture/Laboratoare/6 Verilog Secven\u021bial/"}},c={},u=[],s={toc:u},m="wrapper";function p(e){let{components:r,...a}=e;return(0,i.yg)(m,(0,t.A)({},s,a,{components:r,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"practice-memory"},"Practice: Memory"),(0,i.yg)("p",null,"  Solu\u021bia se afl\u0103 \xeen repo-ul materiei ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture/tree/main/chapters/verilog/memory/drills/tasks"},"GitHub"),". "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Implementa\u021bi modulul register pornind de la declara\u021bia din fi\u0219ierul register.v. Semnalele oe \u0219i we reprezint\u0103 Output Enable, respectiv Write Enable.\noe controleaz\u0103 ie\u0219irea registrului. C\xe2nd oe este high ie\u0219irea este activ\u0103 av\xe2nd valoarea memorat\u0103 de registru. C\xe2nd oe este low ie\u0219irea va fi 0. Acest semnal trebuie s\u0103 fie asincron: modificarea lui va avea efect imediat asupra ie\u0219irii \u0219i nu se va a\u0219tepta tranzi\u021bia semnalului de ceas.\nwe controleaz\u0103 scrierea \xeen registru. C\xe2nd we este high registrul va memora valoarea aflat\u0103 \xeen semnalul de intrare. C\xe2nd we este low valoarea registrului nu se va modifica, ignor\xe2nd practic semnalul de intrare. Acest semnal trebuie s\u0103 fie sincron: modificarea valorii memorate de registru se face doar \xeen momentul tranzi\u021biei semnalului de ceas.\nSemnalul disp_out este folosit pentru afi\u0219are/debugging pe display, iar valoarea acestuia trebuie s\u0103 fie cea memorat\u0103 de registru \xeen momentul curent. \xcen mod normal acest semnal nu este prezent \xeentr-un calculator. Acest semnal nu trebuie s\u0103 fie afectat de oe, valoarea disponibil\u0103 pe disp_out fiind \xeen orice moment egal\u0103 cu valoarea memorat\u0103 de registru.\nSemnalul de reset rst_n este activ pe low (0).\nHint: Pute\u021bi folosi operatorul condi\u0163ional.\nParametriza\u021bi modulul register astfel \xeenc\xe2t data de intrare \u0219i ie\u0219ire din registru s\u0103 aib\u0103 o dimensiune configurabil\u0103.\nHint: Utiliza\u021bi construc\u021bia de limbaj parameter\nPornind de la interfa\u021ba modulului sequential_multiplier din scheletul de cod, implementa\u021bi un automat de st\u0103ri care s\u0103 foloseasc\u0103 instan\u021be parametrizate ale modulului register pentru a \xeendeplini urm\u0103toarele func\u021bionalit\u0103\u021bi:\nLa activarea semnalului write s\u0103 se scrie pe c\xe2te un registru (parametrizat corespunz\u0103tor) valorile semnalelor a \u0219i b\nLa activarea semnalului multiply s\u0103 fie extrase valorile din cele dou\u0103 registre, s\u0103 se \xeenmul\u021beasc\u0103 \u0219i s\u0103 se adauge pe un al treilea registru.\nLa activarea semnalului display, semnalul out s\u0103 primeasc\u0103 valoarea aflat\u0103 pe cel de-al treilea registru.\nPrioritatea celor trei semnale este dat\u0103 de ordinea \xeen care au fost descrise (e.g. dac\u0103 write este activ, se ignor\u0103 semnalele multiply \u0219i display; dac\u0103 multiply este activ, se ignor\u0103 semnalul display)"),(0,i.yg)("li",{parentName:"ul"},"Vi se pune la dispozi\u021bie un RAM de tip Block Memory Generator instan\u021biat \xeen modulul ram_reader. Completa\u021bi modulul astfel \xeenc\xe2t s\u0103 pute\u021bi gestiona citirea din memorie de la o adres\u0103 am_out \xeen momentul \xeen care semnalul read este activ (1).")))}p.isMDXComponent=!0}}]);