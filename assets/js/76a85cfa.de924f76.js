"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[7360],{5680:(e,r,a)=>{a.d(r,{xA:()=>s,yg:()=>g});var i=a(6540);function t(e,r,a){return r in e?Object.defineProperty(e,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[r]=a,e}function n(e,r){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);r&&(i=i.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),a.push.apply(a,i)}return a}function l(e){for(var r=1;r<arguments.length;r++){var a=null!=arguments[r]?arguments[r]:{};r%2?n(Object(a),!0).forEach(function(r){t(e,r,a[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(a,r))})}return e}function o(e,r){if(null==e)return{};var a,i,t=function(e,r){if(null==e)return{};var a,i,t={},n=Object.keys(e);for(i=0;i<n.length;i++)a=n[i],r.indexOf(a)>=0||(t[a]=e[a]);return t}(e,r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)a=n[i],r.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var c=i.createContext({}),u=function(e){var r=i.useContext(c),a=r;return e&&(a="function"==typeof e?e(r):l(l({},r),e)),a},s=function(e){var r=u(e.components);return i.createElement(c.Provider,{value:r},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var r=e.children;return i.createElement(i.Fragment,{},r)}},d=i.forwardRef(function(e,r){var a=e.components,t=e.mdxType,n=e.originalType,c=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=u(a),d=t,g=m["".concat(c,".").concat(d)]||m[d]||p[d]||n;return a?i.createElement(g,l(l({ref:r},s),{},{components:a})):i.createElement(g,l({ref:r},s))});function g(e,r){var a=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var n=a.length,l=new Array(n);l[0]=d;var o={};for(var c in r)hasOwnProperty.call(r,c)&&(o[c]=r[c]);o.originalType=e,o[m]="string"==typeof e?e:t,l[1]=o;for(var u=2;u<n;u++)l[u]=a[u];return i.createElement.apply(null,l)}return i.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5731:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>n,metadata:()=>o,toc:()=>u});var i=a(8168),t=(a(6540),a(5680));const n={},l="Practice: Memory",o={unversionedId:"Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/README",id:"Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/README",title:"Practice: Memory",description:"Solu\u021bia se afl\u0103 \xeen repo-ul materiei GitHub.",source:"@site/docs/Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/README.md",sourceDirName:"Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103",slug:"/Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/",permalink:"/computer-architecture/Laboratoare/5 Verilog Secven\u021bial/Memorie/Practic\u0103/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Memorie",permalink:"/computer-architecture/Laboratoare/5 Verilog Secven\u021bial/Memorie/Teorie/"},next:{title:"6 Verilog Secven\u021bial",permalink:"/computer-architecture/Laboratoare/6 Verilog Secven\u021bial/"}},c={},u=[],s={toc:u},m="wrapper";function p({components:e,...r}){return(0,t.yg)(m,(0,i.A)({},s,r,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"practice-memory"},"Practice: Memory"),(0,t.yg)("p",null,"  Solu\u021bia se afl\u0103 \xeen repo-ul materiei ",(0,t.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture/tree/main/chapters/verilog/memory/drills/tasks"},"GitHub"),". "),(0,t.yg)("p",null," -Modulul ",(0,t.yg)("inlineCode",{parentName:"p"},"Register")," reprezinta cun functioneaza un registru real.Semnalele oe \u0219i we reprezint\u0103 Output Enable, respectiv Write Enable."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"- `oe` controleaz\u0103 ie\u0219irea registrului. C\xe2nd oe este `high` ie\u0219irea este activ\u0103 av\xe2nd valoarea memorat\u0103 de registru. C\xe2nd oe este low ie\u0219irea va fi 0. Acest semnal trebuie s\u0103 fie asincron: modificarea lui va avea efect imediat asupra ie\u0219irii \u0219i nu se va a\u0219tepta tranzi\u021bia semnalului de ceas.\n- `we` controleaz\u0103 scrierea \xeen registru. C\xe2nd we este high registrul va memora valoarea aflat\u0103 \xeen semnalul de intrare. C\xe2nd we este low valoarea registrului nu se va modifica, ignor\xe2nd practic semnalul de intrare. Acest semnal trebuie s\u0103 fie sincron: modificarea valorii memorate de registru se face doar \xeen momentul tranzi\u021biei semnalului de ceas.\n- Semnalul `disp_out` este folosit pentru afi\u0219are/debugging pe display, iar valoarea acestuia trebuie s\u0103 fie cea memorat\u0103 de registru \xeen momentul curent. \xcen mod normal acest semnal nu este prezent \xeentr-un calculator. Acest semnal nu trebuie s\u0103 fie afectat de oe, valoarea disponibil\u0103 pe disp_out fiind \xeen orice moment egal\u0103 cu valoarea memorat\u0103 de registru.\n- Semnalul de reset `rst_n` este activ pe low (0).\n- Hint: Pute\u021bi folosi operatorul condi\u0163ional.\n")),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Pornind de la interfa\u021ba modulului ",(0,t.yg)("inlineCode",{parentName:"li"},"sequential_multiplier")," din scheletul de cod, implementa\u021bi un automat de st\u0103ri care s\u0103 foloseasc\u0103 instan\u021be parametrizate ale modulului ",(0,t.yg)("inlineCode",{parentName:"li"},"register")," pentru a \xeendeplini urm\u0103toarele func\u021bionalit\u0103\u021bi:",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"La activarea semnalului ",(0,t.yg)("inlineCode",{parentName:"li"},"write"),", valorile semnalelor ",(0,t.yg)("inlineCode",{parentName:"li"},"a")," \u0219i ",(0,t.yg)("inlineCode",{parentName:"li"},"b")," sunt scrise \xeen registre parametrizate corespunz\u0103tor."),(0,t.yg)("li",{parentName:"ul"},"La activarea semnalului ",(0,t.yg)("inlineCode",{parentName:"li"},"multiply"),", valorile din cele dou\u0103 registre sunt extrase, \xeenmul\u021bite \u0219i rezultatul ad\u0103ugat \xeentr-un al treilea registru."),(0,t.yg)("li",{parentName:"ul"},"La activarea semnalului ",(0,t.yg)("inlineCode",{parentName:"li"},"display"),", semnalul ",(0,t.yg)("inlineCode",{parentName:"li"},"out")," va primi valoarea aflat\u0103 \xeen al treilea registru."),(0,t.yg)("li",{parentName:"ul"},"Prioritatea celor trei semnale este dat\u0103 de ordinea \xeen care au fost descrise:",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Dac\u0103 ",(0,t.yg)("inlineCode",{parentName:"li"},"write")," este activ, se ignor\u0103 semnalele ",(0,t.yg)("inlineCode",{parentName:"li"},"multiply")," \u0219i ",(0,t.yg)("inlineCode",{parentName:"li"},"display"),"."),(0,t.yg)("li",{parentName:"ul"},"Dac\u0103 ",(0,t.yg)("inlineCode",{parentName:"li"},"multiply")," este activ, se ignor\u0103 semnalul ",(0,t.yg)("inlineCode",{parentName:"li"},"display"),"."))))),(0,t.yg)("li",{parentName:"ul"},"Modulul ",(0,t.yg)("inlineCode",{parentName:"li"},"ram_reader")," este o interfa\u021b\u0103 simpl\u0103 pentru RAM care permite citirea \u0219i scrierea \xeen RAM. Utilizeaz\u0103 semnalul ",(0,t.yg)("inlineCode",{parentName:"li"},"i_w_we")," pentru a controla opera\u021biile de scriere \u0219i semnalul ",(0,t.yg)("inlineCode",{parentName:"li"},"i_w_oe")," pentru a controla opera\u021biile de citire. De asemenea se specifica si adresa de la care sa fie citita/scrisa valoarea cu semnalul ",(0,t.yg)("inlineCode",{parentName:"li"},"i_w_address"))))}p.isMDXComponent=!0}}]);